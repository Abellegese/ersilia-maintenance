# Ersilia Maintenance
This repository contains maintenance workflows for the Ersilia Model Hub.

# General Structure of Maintenence Workflow
The **inspect_model.yml** file defines the GitHub action which is responsible for running the inspections. Within this file, we have several different code blocks which report the result of each method in the **inspect.py** file within **ersilia/publish**. For each check, we have two seperate functions: one of which returns _True_ or _False_ indicating if the check passed or failed, and the other containing the details of a failed check. If a check fails, we create an issue with the details printed. We access these values through the **inspect.py** script in **ersilia/cli/commands**, which stores the results of the **publish/inspect.py** file as a json.

For example, we have in the **commands/inspect.py** file an attribute called _metadata_complete_ and an attribute called _metadata_complete_details_. These are stored by calling the same _metadataComplete_ function with a flag of either 0 (for _metadata_complete_) or 1 (for _metadata_complete_details_) to indicate which type of output we desire from the function. You can see this function _metadataComplete(self, flag)_ in the **publish/inspect.py** file and observe how it conducts several tests on the metadata, both calling the _RepoMetadataFile_ function and conducting several other checks on URLs stored in the model metadata. At each stage, if a test fails, we verify the flag inputted and return a _False_ result if the _flag_ is 0, and add information to our _details_ variable if the _flag_ is 1.

# Updating Functions
If you wanted to add additional checks, you would need to add them three places: **publish/inspect.py**, **commands/inspect.py**, and **inspect_model.yml**. First, create your function with the intended functionality in **publish/inspect.py**. Then, call that function from **commands/inspect.py** and store it in the json file. Lastly, access that json file from **inspect_model.yml** and report the results. Ensure that when you add code to **inspect_model.yml**, you adjust the _exit_ commands as needed so as to not prematurely end the script.

The structure of the functions in all three of these places are pretty formulaic, and you should be able to pretty directly copy structures, especially within **commands/inspect.py** and **inspect_model.yml**.

# Maintaining Repository List
The **repo_info.json** file contains a list of all of the repositories in the ersilia organization. For each repository, we store the last time it was checked as well as the last time it was updated. In the **pickRepo.py** file, we choose among the repositories which have not been inspected since their last update, selecting the repository which was last inspected longest ago and printing it. This is called from the **inspect_model.yml** file, and determines the input for the automated inspect runs. Note that you can still also manually inspect a model by running an action with the model name as the input. To maintain the **repo_info.json** there are several other helper files that may be helpful. The **makeRepoDoc.py** script creates the json from scratch, setting all _most_recent_date_checked_ values to a default date of 01/01/2000 to ensure all repositories are marked as needing to be inspected. Lastly, the **updateRepoDoc.py** script can be ran to update all of the _last_updated_ values and add any additional repositories if there are repositories in the ersilia os database that aren't in the current **repo_info.json** file. I would suggest running **updateRepoDoc.py** in the event that you've run out of repositories to check in the automated workflow runs.
